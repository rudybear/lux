// White Furnace Test â€” energy conservation validation
// 2x2 grid, each cell plots hemisphere-integrated energy vs roughness
// 16 Fibonacci hemisphere samples, unrolled (no loops in Lux)
// Green curve = energy <= 1.0, Red = energy > 1.0

import brdf;

// Weight per sample: 2*PI / 16
const SAMPLE_WEIGHT: scalar = 0.392699;

fn lum(c: vec3) -> scalar {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

fragment {
    in uv: vec2;
    out color: vec4;

    fn main() {
        // 2x2 grid
        let cols: scalar = 2.0;
        let rows: scalar = 2.0;
        let cell_uv: vec2 = fract(vec2(uv.x * cols, uv.y * rows));
        let cell_x: scalar = floor(uv.x * cols);
        let cell_y: scalar = floor(uv.y * rows);

        // X-axis: roughness from 0.05 to 1.0
        let roughness: scalar = cell_uv.x * 0.95 + 0.05;
        let n: vec3 = vec3(0.0, 0.0, 1.0);
        let v: vec3 = vec3(0.0, 0.0, 1.0);

        // Pre-computed Fibonacci hemisphere directions (16 samples)
        let s00: vec3 = vec3(0.0, 0.0, 1.0);
        let s01: vec3 = vec3(0.270, 0.165, 0.949);
        let s02: vec3 = vec3(-0.087, 0.365, 0.927);
        let s03: vec3 = vec3(-0.363, -0.258, 0.895);
        let s04: vec3 = vec3(0.474, -0.145, 0.869);
        let s05: vec3 = vec3(-0.168, 0.522, 0.836);
        let s06: vec3 = vec3(-0.430, -0.413, 0.802);
        let s07: vec3 = vec3(0.635, 0.078, 0.769);
        let s08: vec3 = vec3(-0.315, 0.601, 0.734);
        let s09: vec3 = vec3(-0.375, -0.575, 0.727);
        let s10: vec3 = vec3(0.702, 0.221, 0.677);
        let s11: vec3 = vec3(-0.522, 0.508, 0.685);
        let s12: vec3 = vec3(-0.162, -0.724, 0.671);
        let s13: vec3 = vec3(0.636, 0.414, 0.651);
        let s14: vec3 = vec3(-0.694, 0.257, 0.673);
        let s15: vec3 = vec3(0.223, -0.714, 0.664);

        // NdotL for each sample
        let nl00: scalar = max(dot(n, s00), 0.0);
        let nl01: scalar = max(dot(n, s01), 0.0);
        let nl02: scalar = max(dot(n, s02), 0.0);
        let nl03: scalar = max(dot(n, s03), 0.0);
        let nl04: scalar = max(dot(n, s04), 0.0);
        let nl05: scalar = max(dot(n, s05), 0.0);
        let nl06: scalar = max(dot(n, s06), 0.0);
        let nl07: scalar = max(dot(n, s07), 0.0);
        let nl08: scalar = max(dot(n, s08), 0.0);
        let nl09: scalar = max(dot(n, s09), 0.0);
        let nl10: scalar = max(dot(n, s10), 0.0);
        let nl11: scalar = max(dot(n, s11), 0.0);
        let nl12: scalar = max(dot(n, s12), 0.0);
        let nl13: scalar = max(dot(n, s13), 0.0);
        let nl14: scalar = max(dot(n, s14), 0.0);
        let nl15: scalar = max(dot(n, s15), 0.0);

        // --- Cell (0,0): Lambert (albedo=1.0) ---
        let lamb_sum: scalar =
            lum(lambert_brdf(vec3(1.0), nl00)) * nl00
          + lum(lambert_brdf(vec3(1.0), nl01)) * nl01
          + lum(lambert_brdf(vec3(1.0), nl02)) * nl02
          + lum(lambert_brdf(vec3(1.0), nl03)) * nl03
          + lum(lambert_brdf(vec3(1.0), nl04)) * nl04
          + lum(lambert_brdf(vec3(1.0), nl05)) * nl05
          + lum(lambert_brdf(vec3(1.0), nl06)) * nl06
          + lum(lambert_brdf(vec3(1.0), nl07)) * nl07
          + lum(lambert_brdf(vec3(1.0), nl08)) * nl08
          + lum(lambert_brdf(vec3(1.0), nl09)) * nl09
          + lum(lambert_brdf(vec3(1.0), nl10)) * nl10
          + lum(lambert_brdf(vec3(1.0), nl11)) * nl11
          + lum(lambert_brdf(vec3(1.0), nl12)) * nl12
          + lum(lambert_brdf(vec3(1.0), nl13)) * nl13
          + lum(lambert_brdf(vec3(1.0), nl14)) * nl14
          + lum(lambert_brdf(vec3(1.0), nl15)) * nl15;
        let val0: scalar = lamb_sum * SAMPLE_WEIGHT;

        // --- Cell (1,0): GGX specular only ---
        let f0_spec: vec3 = vec3(0.04);
        let spec_sum: scalar =
            lum(microfacet_brdf(n, v, s00, roughness, f0_spec)) * nl00
          + lum(microfacet_brdf(n, v, s01, roughness, f0_spec)) * nl01
          + lum(microfacet_brdf(n, v, s02, roughness, f0_spec)) * nl02
          + lum(microfacet_brdf(n, v, s03, roughness, f0_spec)) * nl03
          + lum(microfacet_brdf(n, v, s04, roughness, f0_spec)) * nl04
          + lum(microfacet_brdf(n, v, s05, roughness, f0_spec)) * nl05
          + lum(microfacet_brdf(n, v, s06, roughness, f0_spec)) * nl06
          + lum(microfacet_brdf(n, v, s07, roughness, f0_spec)) * nl07
          + lum(microfacet_brdf(n, v, s08, roughness, f0_spec)) * nl08
          + lum(microfacet_brdf(n, v, s09, roughness, f0_spec)) * nl09
          + lum(microfacet_brdf(n, v, s10, roughness, f0_spec)) * nl10
          + lum(microfacet_brdf(n, v, s11, roughness, f0_spec)) * nl11
          + lum(microfacet_brdf(n, v, s12, roughness, f0_spec)) * nl12
          + lum(microfacet_brdf(n, v, s13, roughness, f0_spec)) * nl13
          + lum(microfacet_brdf(n, v, s14, roughness, f0_spec)) * nl14
          + lum(microfacet_brdf(n, v, s15, roughness, f0_spec)) * nl15;
        let val1: scalar = spec_sum * SAMPLE_WEIGHT;

        // --- Cell (0,1): Full PBR, metallic=0.0 ---
        let alb_pbr: vec3 = vec3(0.8);
        let pbr0_sum: scalar =
            lum(pbr_brdf(n, v, s00, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s01, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s02, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s03, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s04, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s05, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s06, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s07, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s08, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s09, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s10, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s11, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s12, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s13, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s14, alb_pbr, roughness, 0.0))
          + lum(pbr_brdf(n, v, s15, alb_pbr, roughness, 0.0));
        let val2: scalar = pbr0_sum * SAMPLE_WEIGHT;

        // --- Cell (1,1): Full PBR, metallic=1.0 ---
        let pbr1_sum: scalar =
            lum(pbr_brdf(n, v, s00, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s01, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s02, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s03, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s04, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s05, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s06, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s07, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s08, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s09, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s10, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s11, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s12, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s13, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s14, alb_pbr, roughness, 1.0))
          + lum(pbr_brdf(n, v, s15, alb_pbr, roughness, 1.0));
        let val3: scalar = pbr1_sum * SAMPLE_WEIGHT;

        // Background
        let bg: vec3 = vec3(0.05, 0.05, 0.07);

        // Plot curves: y position = energy value, scaled to [0, 1.5] range
        let plot0: scalar = clamp(val0, 0.0, 1.5) / 1.5;
        let plot1: scalar = clamp(val1, 0.0, 1.5) / 1.5;
        let plot2: scalar = clamp(val2, 0.0, 1.5) / 1.5;
        let plot3: scalar = clamp(val3, 0.0, 1.5) / 1.5;

        let dist0: scalar = abs(cell_uv.y - plot0);
        let dist1: scalar = abs(cell_uv.y - plot1);
        let dist2: scalar = abs(cell_uv.y - plot2);
        let dist3: scalar = abs(cell_uv.y - plot3);

        let line0: scalar = smoothstep(0.02, 0.005, dist0);
        let line1: scalar = smoothstep(0.02, 0.005, dist1);
        let line2: scalar = smoothstep(0.02, 0.005, dist2);
        let line3: scalar = smoothstep(0.02, 0.005, dist3);

        // Green if energy <= 1.0, red if > 1.0
        let green0: vec3 = (val0 <= 1.0) ? vec3(0.2, 0.9, 0.3) : vec3(0.9, 0.2, 0.1);
        let green1: vec3 = (val1 <= 1.0) ? vec3(0.2, 0.9, 0.3) : vec3(0.9, 0.2, 0.1);
        let green2: vec3 = (val2 <= 1.0) ? vec3(0.2, 0.9, 0.3) : vec3(0.9, 0.2, 0.1);
        let green3: vec3 = (val3 <= 1.0) ? vec3(0.2, 0.9, 0.3) : vec3(0.9, 0.2, 0.1);

        let c0: vec3 = bg + green0 * line0;
        let c1: vec3 = bg + green1 * line1;
        let c2: vec3 = bg + green2 * line2;
        let c3: vec3 = bg + green3 * line3;

        // White reference line at energy=1.0 (y = 1.0/1.5 = 0.667)
        let ref_y: scalar = 1.0 / 1.5;
        let ref_line: scalar = smoothstep(0.008, 0.003, abs(cell_uv.y - ref_y)) * 0.4;
        let ref_col: vec3 = vec3(ref_line);

        // Select cell
        let is_c0: scalar = (cell_x < 0.5 && cell_y < 0.5) ? 1.0 : 0.0;
        let is_c1: scalar = (cell_x > 0.5 && cell_y < 0.5) ? 1.0 : 0.0;
        let is_c2: scalar = (cell_x < 0.5 && cell_y > 0.5) ? 1.0 : 0.0;
        let is_c3: scalar = (cell_x > 0.5 && cell_y > 0.5) ? 1.0 : 0.0;

        let result: vec3 = c0 * is_c0 + c1 * is_c1 + c2 * is_c2 + c3 * is_c3 + ref_col;

        // Grid border
        let gx: scalar = smoothstep(0.0, 0.015, cell_uv.x) * smoothstep(0.0, 0.015, 1.0 - cell_uv.x);
        let gy: scalar = smoothstep(0.0, 0.015, cell_uv.y) * smoothstep(0.0, 0.015, 1.0 - cell_uv.y);

        color = vec4(result * gx * gy, 1.0);
    }
}
