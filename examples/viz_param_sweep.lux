// BRDF Parameter Sweep Heatmaps â€” 2 side-by-side panels
// Left: roughness x metallic, Right: roughness x NdotV
// Uses viridis color ramp for false-color mapping

import brdf;
import color;

fn viridis(t: scalar) -> vec3 {
    let c0: vec3 = vec3(0.267, 0.004, 0.329);
    let c1: vec3 = vec3(0.283, 0.140, 0.458);
    let c2: vec3 = vec3(0.127, 0.566, 0.551);
    let c3: vec3 = vec3(0.544, 0.774, 0.247);
    let c4: vec3 = vec3(0.993, 0.906, 0.144);
    let s: scalar = clamp(t, 0.0, 1.0) * 4.0;
    let seg0: vec3 = mix(c0, c1, clamp(s, 0.0, 1.0));
    let seg1: vec3 = mix(c1, c2, clamp(s - 1.0, 0.0, 1.0));
    let seg2: vec3 = mix(c2, c3, clamp(s - 2.0, 0.0, 1.0));
    let seg3: vec3 = mix(c3, c4, clamp(s - 3.0, 0.0, 1.0));
    let result: vec3 = (s < 1.0) ? seg0
        : (s < 2.0) ? seg1
        : (s < 3.0) ? seg2
        : seg3;
    return result;
}

fragment {
    in uv: vec2;
    out color: vec4;

    fn main() {
        // 1x2 grid (2 columns, 1 row)
        let cols: scalar = 2.0;
        let cell_uv: vec2 = fract(vec2(uv.x * cols, uv.y));
        let cell_x: scalar = floor(uv.x * cols);

        // Fixed vectors for evaluation
        let n: vec3 = vec3(0.0, 0.0, 1.0);
        let v_dir: vec3 = normalize(vec3(0.0, 0.0, 1.0));
        let l_dir: vec3 = normalize(vec3(0.5, 0.5, 0.8));

        // --- Left panel: roughness x metallic ---
        let rough_left: scalar = cell_uv.x * 0.95 + 0.05;
        let metal_left: scalar = cell_uv.y;
        let albedo: vec3 = vec3(0.8, 0.3, 0.2);
        let pbr_result: vec3 = gltf_pbr(n, v_dir, l_dir, albedo, rough_left, metal_left);
        let val_left: scalar = clamp(luminance(pbr_result) * 3.0, 0.0, 1.0);
        let col_left: vec3 = viridis(val_left);

        // --- Right panel: roughness x NdotV ---
        let rough_right: scalar = cell_uv.x * 0.95 + 0.05;
        let ndotv_param: scalar = cell_uv.y * 0.99 + 0.01;
        let v_right: vec3 = normalize(vec3(sqrt(1.0 - ndotv_param * ndotv_param), 0.0, ndotv_param));
        let l_fixed: vec3 = normalize(vec3(0.3, 0.3, 0.8));
        let f0_right: vec3 = vec3(0.04);
        let spec_result: vec3 = microfacet_brdf(n, v_right, l_fixed, rough_right, f0_right);
        let val_right: scalar = clamp(luminance(spec_result) * 5.0, 0.0, 1.0);
        let col_right: vec3 = viridis(val_right);

        // Select panel
        let result: vec3 = (cell_x < 0.5) ? col_left : col_right;

        // Grid border
        let gx: scalar = smoothstep(0.0, 0.01, cell_uv.x) * smoothstep(0.0, 0.01, 1.0 - cell_uv.x);
        let gy: scalar = smoothstep(0.0, 0.01, cell_uv.y) * smoothstep(0.0, 0.01, 1.0 - cell_uv.y);

        color = vec4(result * gx * gy, 1.0);
    }
}
