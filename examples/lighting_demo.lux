// Lighting Demo â€” 3 bands showing directional, point, and spot light evaluation
// Fullscreen fragment shader using the lighting stdlib

import lighting;

fragment {
    in uv: vec2;
    out color: vec4;

    fn main() {
        // Map UV to centered coords
        let p: vec2 = uv * 2.0 - vec2(1.0);

        // Determine which band we're in (3 horizontal bands)
        let band: scalar = floor(uv.y * 3.0);
        let local_v: scalar = fract(uv.y * 3.0);
        let local_p: vec2 = vec2(p.x, local_v * 2.0 - 1.0);

        // Procedural sphere: compute normal from 2D position
        let r: scalar = length(local_p);
        let inside: scalar = step(r, 0.7);
        let nz: scalar = sqrt(max(0.7 * 0.7 - r * r, 0.0));
        let n: vec3 = normalize(vec3(local_p.x, local_p.y, nz));
        let surface_pos: vec3 = vec3(local_p.x, local_p.y, 0.0);

        // Evaluate lighting based on band
        let result: vec3 = vec3(0.0);

        // Band 0 (bottom): Directional light
        let dir_light: vec3 = evaluate_directional_light(
            vec3(0.5, 0.7, 1.0), vec3(1.0, 0.95, 0.9), 1.5, n
        );

        // Band 1 (middle): Point light
        let point_light: vec3 = evaluate_point_light(
            vec3(0.3, 0.3, 1.0), vec3(0.9, 0.7, 0.4), 3.0, 5.0,
            surface_pos, n
        );

        // Band 2 (top): Spot light
        let spot_light: vec3 = evaluate_spot_light(
            vec3(0.0, 0.0, 2.0), vec3(0.0, 0.0, -1.0),
            vec3(0.4, 0.8, 1.0), 4.0, 5.0,
            0.9, 0.7,
            surface_pos, n
        );

        // Select based on band
        let is_band0: scalar = (band < 0.5) ? 1.0 : 0.0;
        let is_band1: scalar = (band > 0.5 && band < 1.5) ? 1.0 : 0.0;
        let is_band2: scalar = (band > 1.5) ? 1.0 : 0.0;

        let lit: vec3 = dir_light * is_band0 + point_light * is_band1 + spot_light * is_band2;

        // Apply to sphere with ambient
        let ambient: vec3 = vec3(0.05, 0.05, 0.08);
        let final_color: vec3 = (ambient + lit) * inside;

        // Add band separator lines
        let sep: scalar = smoothstep(0.0, 0.01, abs(local_v - 0.0)) * smoothstep(0.0, 0.01, abs(local_v - 1.0));
        let final_rgb: vec3 = final_color * sep;

        color = vec4(final_rgb, 1.0);
    }
}
