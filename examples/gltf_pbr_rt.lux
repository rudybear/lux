// glTF PBR Ray Tracing â€” RT pipeline for glTF scenes
// Same PBR math and resource naming as gltf_pbr.lux (forward version)
// so the engine's name-based binding works identically.
//
// Stages: raygen + closest_hit + miss

import brdf;
import color;
import ibl;

raygen {
    acceleration_structure tlas;
    storage_image output_image;

    uniform Camera {
        inv_view: mat4,
        inv_proj: mat4,
    }

    ray_payload payload: vec4;

    fn main() {
        let pixel: vec2 = vec2(launch_id.xy);
        let dims: vec2 = vec2(launch_size.xy);

        // Normalized device coords [-1, 1]
        let ndc: vec2 = (pixel + vec2(0.5)) / dims * 2.0 - vec2(1.0);

        // Camera ray from inverse projection
        let target: vec4 = inv_proj * vec4(ndc.x, ndc.y, 1.0, 1.0);
        let direction: vec4 = inv_view * vec4(normalize(target.xyz), 0.0);

        let origin: vec3 = (inv_view * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
        let dir: vec3 = normalize(direction.xyz);

        // Trace primary ray
        payload = vec4(0.0);
        trace_ray(tlas, 0, 255, 0, 0, 0, origin, 0.001, dir, 1000.0, 0);

        // Write result to storage image
        image_store(output_image, launch_id.xy, payload);
    }
}

closest_hit {
    ray_payload payload: vec4;

    uniform Light {
        light_dir: vec3,
        view_pos: vec3,
    }

    fn main() {
        // Evaluate PBR at hit point
        // For now, use a simple directional light evaluation
        let n: vec3 = vec3(0.0, 1.0, 0.0);
        let v: vec3 = normalize(-world_ray_direction);
        let l: vec3 = normalize(light_dir);
        let albedo: vec3 = vec3(0.8, 0.3, 0.2);
        let roughness: scalar = 0.4;
        let metallic: scalar = 0.0;

        // Direct lighting
        let direct: vec3 = gltf_pbr(n, v, l, albedo, roughness, metallic);
        let n_dot_l: scalar = max(dot(n, l), 0.0);
        let lit: vec3 = direct * n_dot_l;

        // IBL ambient approximation
        let f0: vec3 = mix(vec3(0.04), albedo, metallic);
        let n_dot_v: scalar = max(dot(n, v), 0.001);
        let brdf_lut: vec2 = importance_sample_ggx_approx(n_dot_v, roughness);
        let ibl_spec: vec3 = ibl_specular_contribution(n_dot_v, roughness, f0, brdf_lut);
        let ambient: vec3 = ibl_spec + vec3(0.03) * albedo;

        let hdr: vec3 = lit + ambient;
        let tonemapped: vec3 = tonemap_aces(hdr);
        let final_color: vec3 = linear_to_srgb(tonemapped);

        payload = vec4(final_color, 1.0);
    }
}

miss {
    ray_payload payload: vec4;

    fn main() {
        // Sky gradient
        let dir: vec3 = normalize(world_ray_direction);
        let t: scalar = dir.y * 0.5 + 0.5;
        let sky: vec3 = mix(vec3(0.8, 0.85, 0.9), vec3(0.3, 0.5, 0.8), t);
        payload = vec4(sky, 1.0);
    }
}
