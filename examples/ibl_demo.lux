// IBL Demo â€” Image-Based Lighting visualization
// Shows IBL specular, diffuse, and SH irradiance evaluation

import ibl;
import brdf;
import color;

fragment {
    in uv: vec2;
    out color: vec4;

    fn main() {
        // 2x2 grid layout
        let grid_uv: vec2 = fract(uv * 2.0);
        let cell_x: scalar = floor(uv.x * 2.0);
        let cell_y: scalar = floor(uv.y * 2.0);

        // Map to centered coords for procedural sphere
        let p: vec2 = grid_uv * 2.0 - vec2(1.0);
        let r: scalar = length(p);
        let inside: scalar = step(r, 0.8);
        let nz: scalar = sqrt(max(0.8 * 0.8 - r * r, 0.0));
        let n: vec3 = normalize(vec3(p.x, p.y, nz));
        let v: vec3 = vec3(0.0, 0.0, 1.0);
        let n_dot_v: scalar = max(dot(n, v), 0.001);

        // Material parameters vary across cells
        let roughness: scalar = (cell_x < 0.5) ? 0.2 : 0.8;
        let metallic: scalar = (cell_y < 0.5) ? 0.0 : 1.0;
        let albedo: vec3 = vec3(0.8, 0.3, 0.2);
        let f0: vec3 = mix(vec3(0.04), albedo, metallic);

        // BRDF LUT approximation
        let brdf_lut: vec2 = importance_sample_ggx_approx(n_dot_v, roughness);

        // IBL specular contribution
        let spec: vec3 = ibl_specular_contribution(n_dot_v, roughness, f0, brdf_lut);

        // Fake irradiance using SH (procedural coefficients)
        let sh0: vec3 = vec3(0.8, 0.9, 1.0);
        let sh1: vec3 = vec3(0.1, 0.1, 0.2);
        let sh2: vec3 = vec3(0.2, 0.15, 0.1);
        let sh3: vec3 = vec3(0.15, 0.1, 0.2);
        let irr_l0: vec3 = sh_irradiance_l0(sh0);
        let irr_l1: vec3 = sh_irradiance_l1(sh1, sh2, sh3, n);
        let irradiance: vec3 = irr_l0 + irr_l1;

        // IBL diffuse contribution
        let diff: vec3 = ibl_diffuse_contribution(irradiance, albedo, metallic, f0, n_dot_v);

        // Combine
        let combined: vec3 = spec + diff;
        let tonemapped: vec3 = tonemap_aces(combined);
        let final_color: vec3 = linear_to_srgb(tonemapped) * inside;

        // Grid lines
        let gx: scalar = smoothstep(0.0, 0.02, grid_uv.x) * smoothstep(0.0, 0.02, 1.0 - grid_uv.x);
        let gy: scalar = smoothstep(0.0, 0.02, grid_uv.y) * smoothstep(0.0, 0.02, 1.0 - grid_uv.y);

        color = vec4(final_color * gx * gy, 1.0);
    }
}
