// Lux shader language grammar

start: module_item*

?module_item: const_decl
            | function_def
            | stage_block
            | struct_def
            | type_alias
            | import_decl
            | surface_decl
            | geometry_decl
            | pipeline_decl
            | schedule_decl
            | environment_decl
            | procedural_decl
            | features_decl
            | conditional_block

// --- Top-level declarations ---

const_decl: "const" IDENT ":" type "=" expr ";"

struct_def: "struct" IDENT "{" struct_field ("," struct_field)* ","? "}"

struct_field: IDENT ":" type

type_alias: "type" IDENT "=" type ";"

import_decl: "import" IDENT ";"

// --- Features declarations (compile-time feature flags) ---

features_decl: "features" "{" feature_field ("," feature_field)* ","? "}"
feature_field: IDENT ":" "bool"

// --- Module-level conditional block ---

conditional_block: "if" feature_expr "{" module_item* "}"

// --- Feature expressions (compile-time boolean) ---

?feature_expr: feature_or
?feature_or: feature_and ("||" feature_and)*
?feature_and: feature_not ("&&" feature_not)*
?feature_not: "!" feature_not -> feature_negate
            | feature_primary
?feature_primary: IDENT -> feature_ref
                | "(" feature_expr ")"

// --- Surface declarations ---

surface_decl: "surface" IDENT "{" surface_item ("," surface_item)* ","? "}"

?surface_item: surface_sampler | surface_member | surface_layers
surface_sampler: SAMPLER_KW IDENT ("if" feature_expr)?
SAMPLER_KW: "sampler2d" | "samplerCube"
surface_member: IDENT ":" expr
surface_layers: "layers" "[" layer_call ("," layer_call)* ","? "]"
layer_call: IDENT "(" layer_arg ("," layer_arg)* ","? ")" ("if" feature_expr)?
layer_arg: IDENT ":" expr

// --- Geometry declarations ---

geometry_decl: "geometry" IDENT "{" geometry_item* "}"

?geometry_item: geometry_field
              | geometry_transform
              | geometry_outputs

geometry_field: IDENT ":" type ("if" feature_expr)? ","
geometry_transform: "transform" ":" IDENT "{" block_field ("," block_field)* ","? "}"
geometry_outputs: "outputs" "{" output_binding ("," output_binding)* ","? "}"

output_binding: IDENT ":" expr ("if" feature_expr)?

// --- Pipeline declarations ---

pipeline_decl: "pipeline" IDENT "{" pipeline_member ("," pipeline_member)* ","? "}"

pipeline_member: IDENT ":" expr ("if" feature_expr)?

// --- Schedule declarations ---

schedule_decl: "schedule" IDENT "{" schedule_member ("," schedule_member)* ","? "}"
schedule_member: IDENT ":" IDENT ("if" feature_expr)?

// --- Environment declarations (maps to miss shader in RT) ---

environment_decl: "environment" IDENT "{" surface_item ("," surface_item)* ","? "}"

// --- Procedural declarations (maps to intersection shader in RT) ---

procedural_decl: "procedural" IDENT "{" procedural_item ("," procedural_item)* ","? "}"
?procedural_item: IDENT ":" expr -> procedural_member

// --- Stage blocks ---

stage_block: STAGE_TYPE "{" stage_item* "}"

STAGE_TYPE: "vertex" | "fragment" | "raygen" | "closest_hit" | "any_hit" | "miss" | "intersection" | "callable"

?stage_item: in_decl
           | out_decl
           | uniform_block
           | push_block
           | sampler_decl
           | function_def
           | ray_payload_decl
           | hit_attribute_decl
           | callable_data_decl
           | accel_decl
           | storage_image_decl
           | storage_buffer_decl

in_decl: "in" IDENT ":" type ";"
out_decl: "out" IDENT ":" type ";"

uniform_block: "uniform" IDENT "{" block_field ("," block_field)* ","? "}"
push_block: "push" IDENT "{" block_field ("," block_field)* ","? "}"

block_field: IDENT ":" type

sampler_decl: SAMPLER_TYPE IDENT ";"
SAMPLER_TYPE: "sampler2d" | "samplerCube"

// RT-specific stage items
ray_payload_decl: "ray_payload" IDENT ":" type ";"
hit_attribute_decl: "hit_attribute" IDENT ":" type ";"
callable_data_decl: "callable_data" IDENT ":" type ";"
accel_decl: "acceleration_structure" IDENT ";"
storage_image_decl: "storage_image" IDENT ";"
storage_buffer_decl: "storage_buffer" IDENT ":" type ";"

// --- Functions ---

function_def: attribute* "fn" IDENT "(" param_list? ")" ("->" type)? "{" statement* "}"
attribute: "@" IDENT

param_list: param ("," param)*
param: IDENT ":" type

// --- Statements ---

?statement: let_stmt
          | assign_stmt
          | return_stmt
          | if_stmt
          | expr_stmt

let_stmt: "let" IDENT ":" type "=" expr ";"
assign_stmt: assign_target "=" expr ";"
return_stmt: "return" expr ";"
if_stmt: "if" "(" expr ")" "{" statement* "}" ("else" "{" statement* "}")?

expr_stmt: expr ";"

?assign_target: swizzle_access -> assign_swizzle
              | field_access   -> assign_field
              | index_access   -> assign_index
              | IDENT          -> assign_ident

// --- Types ---

?type: base_type

base_type: TYPE_NAME

TYPE_NAME: "scalar" | "int" | "uint" | "bool"
         | "vec2" | "vec3" | "vec4"
         | "ivec2" | "ivec3" | "ivec4"
         | "uvec2" | "uvec3" | "uvec4"
         | "mat2" | "mat3" | "mat4"
         | "sampler2d" | "samplerCube" | "void"
         | "acceleration_structure"
         | IDENT

// --- Expressions (precedence climbing) ---

?expr: ternary_expr

?ternary_expr: or_expr ("?" expr ":" ternary_expr)?

?or_expr: and_expr ("||" and_expr)*
?and_expr: equality_expr ("&&" equality_expr)*
?equality_expr: comparison_expr (EQUALITY_OP comparison_expr)*
?comparison_expr: additive_expr (COMPARISON_OP additive_expr)*
?additive_expr: multiplicative_expr (ADD_OP multiplicative_expr)*
?multiplicative_expr: unary_expr (MUL_OP unary_expr)*

EQUALITY_OP: "==" | "!="
COMPARISON_OP: "<=" | ">=" | "<" | ">"
ADD_OP: "+" | "-"
MUL_OP: "*" | "/" | "%"

?unary_expr: UNARY_OP unary_expr -> unary
           | postfix_expr

UNARY_OP: "-" | "!"

?postfix_expr: primary
             | call_expr
             | constructor_expr
             | swizzle_access
             | field_access
             | index_access

call_expr: postfix_expr "(" arg_list? ")"
constructor_expr: TYPE_CONSTRUCTOR "(" arg_list? ")"
swizzle_access: postfix_expr "." SWIZZLE
field_access: postfix_expr "." IDENT
index_access: postfix_expr "[" expr "]"

TYPE_CONSTRUCTOR: "vec2" | "vec3" | "vec4"
                | "ivec2" | "ivec3" | "ivec4"
                | "uvec2" | "uvec3" | "uvec4"
                | "mat2" | "mat3" | "mat4"

arg_list: expr ("," expr)*

// Swizzle: 1-4 components from {x,y,z,w} or {r,g,b,a}
SWIZZLE: /[xyzw]{1,4}/ | /[rgba]{1,4}/

?primary: NUMBER -> number_lit
        | "true"  -> bool_true
        | "false" -> bool_false
        | IDENT   -> var_ref
        | "(" expr ")"

NUMBER: /[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?/ | /[0-9]+[eE][+-]?[0-9]+/ | /[0-9]*\.[0-9]+([eE][+-]?[0-9]+)?/ | /[0-9]+/
IDENT: /[a-zA-Z_][a-zA-Z0-9_]*/

%ignore /\/\/.*/          // line comments
%ignore /[ \t\f\r\n]+/   // whitespace
