"""SPIR-V assembly text generator."""

from __future__ import annotations
from luxc.parser.ast_nodes import (
    Module, StageBlock, FunctionDef, LetStmt, AssignStmt, ReturnStmt,
    IfStmt, ExprStmt, NumberLit, BoolLit, VarRef, BinaryOp, UnaryOp,
    CallExpr, ConstructorExpr, FieldAccess, SwizzleAccess, IndexAccess,
    TernaryExpr, AssignTarget,
)
from luxc.codegen.spirv_types import TypeRegistry
from luxc.codegen.glsl_ext import GLSL_STD_450, LUX_TO_GLSL
from luxc.analysis.layout_assigner import compute_std140_offsets
from luxc.builtins.types import (
    resolve_type, VectorType, MatrixType, ScalarType, TYPE_MAP,
)


def generate_spirv(module: Module, stage: StageBlock) -> str:
    gen = SpvGenerator(module, stage)
    return gen.generate()


class SpvGenerator:
    def __init__(self, module: Module, stage: StageBlock):
        self.module = module
        self.stage = stage
        self.reg = TypeRegistry()
        self.body_lines: list[str] = []
        self.decorations: list[str] = []
        self.annotations: list[str] = []  # OpName etc.
        self.global_vars: list[str] = []
        self.var_map: dict[str, str] = {}        # lux name -> %id of variable (pointer)
        self.var_types: dict[str, str] = {}       # lux name -> lux type name
        self.var_storage: dict[str, str] = {}     # lux name -> storage class
        self.interface_ids: list[str] = []         # for OpEntryPoint
        self.glsl_ext_id: str | None = None
        self._label_counter = 0

        # Uniform block info
        self.uniform_var_ids: dict[str, str] = {}     # block name -> %id
        self.uniform_struct_ids: dict[str, str] = {}   # block name -> struct type %id
        self.uniform_field_indices: dict[str, int] = {} # field name -> index
        self.uniform_block_for_field: dict[str, str] = {} # field name -> block name

        # Push constant info
        self.push_var_ids: dict[str, str] = {}
        self.push_struct_ids: dict[str, str] = {}
        self.push_field_indices: dict[str, int] = {}
        self.push_block_for_field: dict[str, str] = {}

        # gl_PerVertex output block for vertex shader
        self.per_vertex_var_id: str | None = None
        self.per_vertex_struct_id: str | None = None

    def _next_label(self) -> str:
        self._label_counter += 1
        return f"%label_{self._label_counter}"

    def generate(self) -> str:
        self.glsl_ext_id = self.reg.next_id()

        # Pre-declare types we'll need
        self._declare_globals()

        # Generate function bodies
        fn_code = []
        for fn in self.stage.functions:
            fn_code.extend(self._gen_function(fn))

        # Assemble sections
        lines = []

        # Header
        lines.append("; SPIR-V")
        lines.append("; Generated by luxc")
        lines.append("OpCapability Shader")
        lines.append(f"{self.glsl_ext_id} = OpExtInstImport \"GLSL.std.450\"")
        lines.append("OpMemoryModel Logical GLSL450")

        # Entry point
        exec_model = "Vertex" if self.stage.stage_type == "vertex" else "Fragment"
        iface = " ".join(self.interface_ids)
        lines.append(f"OpEntryPoint {exec_model} %main \"main\" {iface}")

        # Execution mode
        if self.stage.stage_type == "fragment":
            lines.append("OpExecutionMode %main OriginUpperLeft")

        # Debug names
        lines.append('OpName %main "main"')
        for name, vid in self.var_map.items():
            lines.append(f'OpName {vid} "{name}"')
        for bname, sid in self.uniform_struct_ids.items():
            lines.append(f'OpName {sid} "{bname}"')
        for bname, sid in self.push_struct_ids.items():
            lines.append(f'OpName {sid} "{bname}"')
        if self.per_vertex_struct_id:
            lines.append(f'OpName {self.per_vertex_struct_id} "gl_PerVertex"')
            lines.append(f'OpName {self.per_vertex_var_id} ""')

        # Decorations
        lines.extend(self.decorations)

        # Type + constant declarations (unified, dependency-ordered)
        lines.extend(self.reg.emit_declarations())

        # Global variables
        lines.extend(self.global_vars)

        # Functions
        lines.extend(fn_code)

        return "\n".join(lines) + "\n"

    def _declare_globals(self):
        """Declare all global variables, types, and decorations."""

        # --- Input variables ---
        for inp in self.stage.inputs:
            type_id = self.reg.lux_type_to_spirv(inp.type_name)
            ptr_type = self.reg.pointer("Input", type_id)
            var_id = self.reg.next_id()
            self.global_vars.append(f"{var_id} = OpVariable {ptr_type} Input")
            self.decorations.append(f"OpDecorate {var_id} Location {inp.location}")
            self.var_map[inp.name] = var_id
            self.var_types[inp.name] = inp.type_name
            self.var_storage[inp.name] = "Input"
            self.interface_ids.append(var_id)

        # --- Output variables ---
        for out in self.stage.outputs:
            type_id = self.reg.lux_type_to_spirv(out.type_name)
            ptr_type = self.reg.pointer("Output", type_id)
            var_id = self.reg.next_id()
            self.global_vars.append(f"{var_id} = OpVariable {ptr_type} Output")
            self.decorations.append(f"OpDecorate {var_id} Location {out.location}")
            self.var_map[out.name] = var_id
            self.var_types[out.name] = out.type_name
            self.var_storage[out.name] = "Output"
            self.interface_ids.append(var_id)

        # --- gl_PerVertex for vertex shaders (builtin_position) ---
        if self.stage.stage_type == "vertex":
            vec4_id = self.reg.lux_type_to_spirv("vec4")
            float_id = self.reg.float32()
            uint_id = self.reg.uint32()
            # gl_PerVertex struct: { vec4 gl_Position, float gl_PointSize, float gl_ClipDistance[], float gl_CullDistance[] }
            # Minimal: just gl_Position
            arr_1 = self._make_array_type(float_id, 1)
            struct_id = self.reg.struct("gl_PerVertex", [vec4_id, float_id, arr_1, arr_1])
            self.per_vertex_struct_id = struct_id
            ptr_type = self.reg.pointer("Output", struct_id)
            var_id = self.reg.next_id()
            self.global_vars.append(f"{var_id} = OpVariable {ptr_type} Output")
            self.per_vertex_var_id = var_id
            self.interface_ids.append(var_id)

            # Decorations for gl_PerVertex
            self.decorations.append(f"OpDecorate {struct_id} Block")
            self.decorations.append(f"OpMemberDecorate {struct_id} 0 BuiltIn Position")
            self.decorations.append(f"OpMemberDecorate {struct_id} 1 BuiltIn PointSize")
            self.decorations.append(f"OpMemberDecorate {struct_id} 2 BuiltIn ClipDistance")
            self.decorations.append(f"OpMemberDecorate {struct_id} 3 BuiltIn CullDistance")

            self.var_map["builtin_position"] = var_id
            self.var_types["builtin_position"] = "vec4"
            self.var_storage["builtin_position"] = "Output"

        # --- Uniform blocks ---
        for ub in self.stage.uniforms:
            member_types = []
            for i, field in enumerate(ub.fields):
                tid = self.reg.lux_type_to_spirv(field.type_name)
                member_types.append(tid)
                self.uniform_field_indices[field.name] = i
                self.uniform_block_for_field[field.name] = ub.name
                self.var_types[field.name] = field.type_name

            struct_id = self.reg.struct(ub.name, member_types)
            self.uniform_struct_ids[ub.name] = struct_id
            ptr_type = self.reg.pointer("Uniform", struct_id)
            var_id = self.reg.next_id()
            self.global_vars.append(f"{var_id} = OpVariable {ptr_type} Uniform")
            self.uniform_var_ids[ub.name] = var_id
            self.interface_ids.append(var_id)

            # Decorations
            self.decorations.append(f"OpDecorate {struct_id} Block")
            self.decorations.append(f"OpDecorate {var_id} DescriptorSet {ub.set_number}")
            self.decorations.append(f"OpDecorate {var_id} Binding {ub.binding}")

            # Member offsets (std140)
            offsets = compute_std140_offsets(ub.fields)
            for i, offset in enumerate(offsets):
                self.decorations.append(f"OpMemberDecorate {struct_id} {i} Offset {offset}")
                # MatrixStride for matrix members
                if ub.fields[i].type_name in ("mat2", "mat3", "mat4"):
                    self.decorations.append(f"OpMemberDecorate {struct_id} {i} ColMajor")
                    self.decorations.append(f"OpMemberDecorate {struct_id} {i} MatrixStride 16")

        # --- Push constant blocks ---
        for pb in self.stage.push_constants:
            member_types = []
            for i, field in enumerate(pb.fields):
                tid = self.reg.lux_type_to_spirv(field.type_name)
                member_types.append(tid)
                self.push_field_indices[field.name] = i
                self.push_block_for_field[field.name] = pb.name
                self.var_types[field.name] = field.type_name

            struct_id = self.reg.struct(pb.name, member_types)
            self.push_struct_ids[pb.name] = struct_id
            ptr_type = self.reg.pointer("PushConstant", struct_id)
            var_id = self.reg.next_id()
            self.global_vars.append(f"{var_id} = OpVariable {ptr_type} PushConstant")
            self.push_var_ids[pb.name] = var_id
            self.interface_ids.append(var_id)

            self.decorations.append(f"OpDecorate {struct_id} Block")
            offsets = compute_std140_offsets(pb.fields)
            for i, offset in enumerate(offsets):
                self.decorations.append(f"OpMemberDecorate {struct_id} {i} Offset {offset}")

        # --- Samplers (separate sampler + texture for WebGPU compatibility) ---
        for sam in self.stage.samplers:
            # Sampler state variable
            sampler_type = self.reg.sampler_type()
            sampler_ptr = self.reg.pointer("UniformConstant", sampler_type)
            sampler_var = self.reg.next_id()
            self.global_vars.append(f"{sampler_var} = OpVariable {sampler_ptr} UniformConstant")
            self.decorations.append(f"OpDecorate {sampler_var} DescriptorSet {sam.set_number}")
            self.decorations.append(f"OpDecorate {sampler_var} Binding {sam.binding}")
            self.interface_ids.append(sampler_var)

            # Texture image variable
            image_type = self.reg.image_type()
            image_ptr = self.reg.pointer("UniformConstant", image_type)
            texture_var = self.reg.next_id()
            self.global_vars.append(f"{texture_var} = OpVariable {image_ptr} UniformConstant")
            self.decorations.append(f"OpDecorate {texture_var} DescriptorSet {sam.set_number}")
            self.decorations.append(f"OpDecorate {texture_var} Binding {sam.texture_binding}")
            self.interface_ids.append(texture_var)

            # Store both var IDs for use in sample() codegen
            self.var_map[sam.name + ".__sampler"] = sampler_var
            self.var_map[sam.name + ".__texture"] = texture_var
            self.var_types[sam.name] = "sampler2d"
            self.var_storage[sam.name] = "UniformConstant"

    def _make_array_type(self, elem_type: str, length: int) -> str:
        length_id = self.reg.const_uint(length)
        return self.reg.array(elem_type, length_id)

    def _gen_function(self, fn: FunctionDef) -> list[str]:
        lines = []
        void_type = self.reg.void()
        fn_type = self.reg.function_type(void_type)

        lines.append(f"%main = OpFunction {void_type} None {fn_type}")
        label = self.reg.next_id()
        lines.append(f"{label} = OpLabel")

        # Local variables (let statements need Function storage class pointers)
        self.local_vars: dict[str, str] = {}  # name -> %id (pointer)
        self.local_types: dict[str, str] = {}  # name -> lux type name

        # SPIR-V requires all OpVariable in a function to be at the top of
        # the first block. We use a deferred list that _alloc_local adds to.
        self._var_decls: list[str] = []
        self._pre_declare_locals(fn.body)

        body_lines = []
        for stmt in fn.body:
            body_lines.extend(self._gen_stmt(stmt))

        # Emit variable declarations first, then body
        lines.extend(self._var_decls)
        lines.extend(body_lines)

        # If this is main and no explicit return, add OpReturn
        lines.append("OpReturn")
        lines.append("OpFunctionEnd")
        return lines

    def _alloc_local(self, name: str, type_name: str) -> str:
        """Allocate a local variable, adding its OpVariable to the deferred list."""
        type_id = self.reg.lux_type_to_spirv(type_name)
        ptr_type = self.reg.pointer("Function", type_id)
        var_id = self.reg.next_id()
        self._var_decls.append(f"{var_id} = OpVariable {ptr_type} Function")
        self.local_vars[name] = var_id
        self.local_types[name] = type_name
        return var_id

    def _pre_declare_locals(self, stmts: list):
        """Pre-declare all local variables at the top of the function block."""
        for stmt in stmts:
            if isinstance(stmt, LetStmt):
                self._alloc_local(stmt.name, stmt.type_name)
            elif isinstance(stmt, IfStmt):
                self._pre_declare_locals(stmt.then_body)
                self._pre_declare_locals(stmt.else_body)

    def _gen_stmt(self, stmt) -> list[str]:
        lines = []

        if isinstance(stmt, LetStmt):
            # Variable already declared in _pre_declare_locals
            var_id = self.local_vars[stmt.name]
            # Evaluate RHS and store
            val_id, val_lines = self._gen_expr(stmt.value)
            lines.extend(val_lines)
            lines.append(f"OpStore {var_id} {val_id}")

        elif isinstance(stmt, AssignStmt):
            target = stmt.target
            if isinstance(target, AssignTarget):
                target = target.expr
            val_id, val_lines = self._gen_expr(stmt.value)
            lines.extend(val_lines)
            ptr_id, ptr_lines = self._gen_store_target(target)
            lines.extend(ptr_lines)
            lines.append(f"OpStore {ptr_id} {val_id}")

        elif isinstance(stmt, ReturnStmt):
            val_id, val_lines = self._gen_expr(stmt.value)
            lines.extend(val_lines)
            lines.append(f"OpReturnValue {val_id}")

        elif isinstance(stmt, IfStmt):
            cond_id, cond_lines = self._gen_expr(stmt.condition)
            lines.extend(cond_lines)
            then_label = self._next_label()
            else_label = self._next_label()
            merge_label = self._next_label()
            lines.append(f"OpSelectionMerge {merge_label} None")
            if stmt.else_body:
                lines.append(f"OpBranchConditional {cond_id} {then_label} {else_label}")
            else:
                lines.append(f"OpBranchConditional {cond_id} {then_label} {merge_label}")
            lines.append(f"{then_label} = OpLabel")
            for s in stmt.then_body:
                lines.extend(self._gen_stmt(s))
            lines.append(f"OpBranch {merge_label}")
            if stmt.else_body:
                lines.append(f"{else_label} = OpLabel")
                for s in stmt.else_body:
                    lines.extend(self._gen_stmt(s))
                lines.append(f"OpBranch {merge_label}")
            lines.append(f"{merge_label} = OpLabel")

        elif isinstance(stmt, ExprStmt):
            _, expr_lines = self._gen_expr(stmt.expr)
            lines.extend(expr_lines)

        return lines

    def _gen_store_target(self, target) -> tuple[str, list[str]]:
        """Return (pointer_id, lines) for a store target."""
        lines = []

        if isinstance(target, VarRef):
            name = target.name
            # builtin_position -> access chain into gl_PerVertex[0]
            if name == "builtin_position" and self.per_vertex_var_id:
                vec4_id = self.reg.lux_type_to_spirv("vec4")
                ptr_type = self.reg.pointer("Output", vec4_id)
                idx = self.reg.const_int(0, signed=True)
                ac_id = self.reg.next_id()
                lines.append(f"{ac_id} = OpAccessChain {ptr_type} {self.per_vertex_var_id} {idx}")
                return ac_id, lines

            if name in self.local_vars:
                return self.local_vars[name], lines
            if name in self.var_map:
                return self.var_map[name], lines
            raise ValueError(f"Unknown store target: {name}")

        elif isinstance(target, SwizzleAccess):
            # For swizzle write, we need the pointer to the whole vector,
            # then do an OpLoad, OpVectorShuffle, OpStore
            # For simplicity in v1, only support full assignment
            return self._gen_store_target(target.object)

        elif isinstance(target, FieldAccess):
            return self._gen_store_target(target.object)

        elif isinstance(target, IndexAccess):
            obj_ptr, obj_lines = self._gen_store_target(target.object)
            lines.extend(obj_lines)
            idx_id, idx_lines = self._gen_expr(target.index)
            lines.extend(idx_lines)
            # Need to know the result type
            result_id = self.reg.next_id()
            return result_id, lines

        raise ValueError(f"Unknown store target type: {type(target).__name__}")

    def _gen_expr(self, expr) -> tuple[str, list[str]]:
        """Generate SPIR-V instructions for an expression.

        Returns (result_id, lines).
        """
        lines = []

        if isinstance(expr, NumberLit):
            val = expr.value
            if "." in val or "e" in val.lower():
                result = self.reg.const_float(float(val))
            else:
                # Integer literal, but in Lux v1 we treat all as float
                result = self.reg.const_float(float(val))
            return result, lines

        elif isinstance(expr, BoolLit):
            return self.reg.const_bool(expr.value), lines

        elif isinstance(expr, VarRef):
            return self._gen_var_load(expr.name, lines)

        elif isinstance(expr, BinaryOp):
            return self._gen_binary(expr, lines)

        elif isinstance(expr, UnaryOp):
            return self._gen_unary(expr, lines)

        elif isinstance(expr, CallExpr):
            return self._gen_call(expr, lines)

        elif isinstance(expr, ConstructorExpr):
            return self._gen_constructor(expr, lines)

        elif isinstance(expr, SwizzleAccess):
            return self._gen_swizzle(expr, lines)

        elif isinstance(expr, FieldAccess):
            return self._gen_field_access(expr, lines)

        elif isinstance(expr, IndexAccess):
            return self._gen_index_access(expr, lines)

        elif isinstance(expr, TernaryExpr):
            return self._gen_ternary(expr, lines)

        raise ValueError(f"Unknown expr type: {type(expr).__name__}")

    def _gen_var_load(self, name: str, lines: list[str]) -> tuple[str, list[str]]:
        """Load a variable value."""
        # Check uniform fields (need OpAccessChain)
        if name in self.uniform_field_indices:
            block_name = self.uniform_block_for_field[name]
            var_id = self.uniform_var_ids[block_name]
            field_idx = self.uniform_field_indices[name]
            field_type = self.var_types[name]
            type_id = self.reg.lux_type_to_spirv(field_type)
            ptr_type = self.reg.pointer("Uniform", type_id)
            idx_id = self.reg.const_int(field_idx, signed=True)
            ac_id = self.reg.next_id()
            lines.append(f"{ac_id} = OpAccessChain {ptr_type} {var_id} {idx_id}")
            result = self.reg.next_id()
            lines.append(f"{result} = OpLoad {type_id} {ac_id}")
            return result, lines

        # Check push constant fields
        if name in self.push_field_indices:
            block_name = self.push_block_for_field[name]
            var_id = self.push_var_ids[block_name]
            field_idx = self.push_field_indices[name]
            field_type = self.var_types[name]
            type_id = self.reg.lux_type_to_spirv(field_type)
            ptr_type = self.reg.pointer("PushConstant", type_id)
            idx_id = self.reg.const_int(field_idx, signed=True)
            ac_id = self.reg.next_id()
            lines.append(f"{ac_id} = OpAccessChain {ptr_type} {var_id} {idx_id}")
            result = self.reg.next_id()
            lines.append(f"{result} = OpLoad {type_id} {ac_id}")
            return result, lines

        # Check local variables
        if name in self.local_vars:
            type_name = self.local_types[name]
            type_id = self.reg.lux_type_to_spirv(type_name)
            result = self.reg.next_id()
            lines.append(f"{result} = OpLoad {type_id} {self.local_vars[name]}")
            return result, lines

        # Check global vars (inputs/outputs)
        if name in self.var_map:
            type_name = self.var_types[name]
            type_id = self.reg.lux_type_to_spirv(type_name)
            result = self.reg.next_id()
            lines.append(f"{result} = OpLoad {type_id} {self.var_map[name]}")
            return result, lines

        # Check module constants
        for c in self.module.constants:
            if c.name == name:
                return self._gen_expr(c.value)

        raise ValueError(f"Undefined variable in codegen: {name}")

    def _gen_binary(self, expr: BinaryOp, lines: list[str]) -> tuple[str, list[str]]:
        left_id, left_lines = self._gen_expr(expr.left)
        lines.extend(left_lines)
        right_id, right_lines = self._gen_expr(expr.right)
        lines.extend(right_lines)

        result_type = self.reg.lux_type_to_spirv(expr.resolved_type)
        result = self.reg.next_id()

        lt = self._resolve_expr_lux_type(expr.left)
        rt = self._resolve_expr_lux_type(expr.right)

        op = expr.op

        if op in ("==", "!=", "<", ">", "<=", ">="):
            bool_type = self.reg.bool_type()
            cmp_ops = {
                "==": "OpFOrdEqual", "!=": "OpFOrdNotEqual",
                "<": "OpFOrdLessThan", ">": "OpFOrdGreaterThan",
                "<=": "OpFOrdLessThanEqual", ">=": "OpFOrdGreaterThanEqual",
            }
            lines.append(f"{result} = {cmp_ops[op]} {bool_type} {left_id} {right_id}")
            return result, lines

        if op in ("&&", "||"):
            bool_type = self.reg.bool_type()
            logic_op = "OpLogicalAnd" if op == "&&" else "OpLogicalOr"
            lines.append(f"{result} = {logic_op} {bool_type} {left_id} {right_id}")
            return result, lines

        # Arithmetic ops
        spv_op = self._select_arith_op(op, lt, rt)

        # Handle mixed vec/scalar for +, -, /, % by splatting scalar to vec
        from luxc.builtins.types import resolve_alias_chain
        lt_resolved = resolve_alias_chain(lt)
        rt_resolved = resolve_alias_chain(rt)
        lt_type = resolve_type(lt_resolved)
        rt_type = resolve_type(rt_resolved)
        if op in ("+", "-", "/", "%"):
            if isinstance(lt_type, VectorType) and isinstance(rt_type, ScalarType):
                splat_id = self.reg.next_id()
                vec_type = self.reg.lux_type_to_spirv(lt_resolved)
                components = " ".join([right_id] * lt_type.size)
                lines.append(f"{splat_id} = OpCompositeConstruct {vec_type} {components}")
                right_id = splat_id
            elif isinstance(lt_type, ScalarType) and isinstance(rt_type, VectorType):
                splat_id = self.reg.next_id()
                vec_type = self.reg.lux_type_to_spirv(rt_resolved)
                components = " ".join([left_id] * rt_type.size)
                lines.append(f"{splat_id} = OpCompositeConstruct {vec_type} {components}")
                left_id = splat_id

        # OpVectorTimesScalar requires vector as first operand, scalar as second.
        # When expression is scalar * vec, swap operand order.
        if spv_op == "OpVectorTimesScalar" and isinstance(lt_type, ScalarType) and isinstance(rt_type, VectorType):
            lines.append(f"{result} = {spv_op} {result_type} {right_id} {left_id}")
        elif spv_op == "OpMatrixTimesScalar" and isinstance(lt_type, ScalarType) and isinstance(rt_type, MatrixType):
            lines.append(f"{result} = {spv_op} {result_type} {right_id} {left_id}")
        else:
            lines.append(f"{result} = {spv_op} {result_type} {left_id} {right_id}")
        return result, lines

    def _select_arith_op(self, op: str, lt: str, rt: str) -> str:
        from luxc.builtins.types import resolve_alias_chain
        lt_type = resolve_type(resolve_alias_chain(lt))
        rt_type = resolve_type(resolve_alias_chain(rt))

        if op == "+":
            return "OpFAdd"
        elif op == "-":
            return "OpFSub"
        elif op == "/":
            return "OpFDiv"
        elif op == "%":
            return "OpFMod"
        elif op == "*":
            # Matrix * Vector
            if isinstance(lt_type, MatrixType) and isinstance(rt_type, VectorType):
                return "OpMatrixTimesVector"
            # Vector * Matrix
            if isinstance(lt_type, VectorType) and isinstance(rt_type, MatrixType):
                return "OpVectorTimesMatrix"
            # Matrix * Matrix
            if isinstance(lt_type, MatrixType) and isinstance(rt_type, MatrixType):
                return "OpMatrixTimesMatrix"
            # Matrix * Scalar
            if isinstance(lt_type, MatrixType) and isinstance(rt_type, ScalarType):
                return "OpMatrixTimesScalar"
            if isinstance(lt_type, ScalarType) and isinstance(rt_type, MatrixType):
                return "OpMatrixTimesScalar"
            # Vector * Scalar or Scalar * Vector
            if isinstance(lt_type, VectorType) and isinstance(rt_type, ScalarType):
                return "OpVectorTimesScalar"
            if isinstance(lt_type, ScalarType) and isinstance(rt_type, VectorType):
                return "OpVectorTimesScalar"
            return "OpFMul"

        return "OpFMul"

    def _gen_unary(self, expr: UnaryOp, lines: list[str]) -> tuple[str, list[str]]:
        operand_id, op_lines = self._gen_expr(expr.operand)
        lines.extend(op_lines)
        result_type = self.reg.lux_type_to_spirv(expr.resolved_type)
        result = self.reg.next_id()
        if expr.op == "-":
            lines.append(f"{result} = OpFNegate {result_type} {operand_id}")
        elif expr.op == "!":
            lines.append(f"{result} = OpLogicalNot {result_type} {operand_id}")
        return result, lines

    def _gen_call(self, expr: CallExpr, lines: list[str]) -> tuple[str, list[str]]:
        if not isinstance(expr.func, VarRef):
            raise ValueError("Non-simple function calls not supported")

        fname = expr.func.name

        # sample(tex, uv) — handle before general arg generation since tex
        # is not a loadable variable (it's split into sampler + texture)
        if fname == "sample":
            sampler_arg = expr.args[0]
            # Generate UV argument normally
            uv_id, uv_lines = self._gen_expr(expr.args[1])
            lines.extend(uv_lines)
            result_type = self.reg.lux_type_to_spirv(expr.resolved_type)
            result = self.reg.next_id()
            if isinstance(sampler_arg, VarRef) and sampler_arg.name + ".__sampler" in self.var_map:
                sam_name = sampler_arg.name
                # Load the texture image
                img_type = self.reg.image_type()
                tex_loaded = self.reg.next_id()
                lines.append(f"{tex_loaded} = OpLoad {img_type} {self.var_map[sam_name + '.__texture']}")
                # Load the sampler
                samp_type = self.reg.sampler_type()
                samp_loaded = self.reg.next_id()
                lines.append(f"{samp_loaded} = OpLoad {samp_type} {self.var_map[sam_name + '.__sampler']}")
                # Combine into sampled image
                sampled_img_type = self.reg.sampled_image_type()
                combined = self.reg.next_id()
                lines.append(f"{combined} = OpSampledImage {sampled_img_type} {tex_loaded} {samp_loaded}")
                # Sample
                lines.append(f"{result} = OpImageSampleImplicitLod {result_type} {combined} {uv_id}")
            else:
                # Fallback: combined image sampler (legacy)
                tex_id, tex_lines = self._gen_expr(sampler_arg)
                lines.extend(tex_lines)
                lines.append(f"{result} = OpImageSampleImplicitLod {result_type} {tex_id} {uv_id}")
            return result, lines

        # Generate arguments
        arg_ids = []
        for arg in expr.args:
            aid, alines = self._gen_expr(arg)
            lines.extend(alines)
            arg_ids.append(aid)

        result_type = self.reg.lux_type_to_spirv(expr.resolved_type)
        result = self.reg.next_id()

        # atan with 2 args -> Atan2 (not Atan)
        if fname == "atan" and len(arg_ids) == 2:
            args_str = " ".join(arg_ids)
            lines.append(f"{result} = OpExtInst {result_type} {self.glsl_ext_id} Atan2 {args_str}")
            return result, lines

        # mod -> OpFMod (core SPIR-V op, not GLSL.std.450)
        if fname == "mod":
            lines.append(f"{result} = OpFMod {result_type} {arg_ids[0]} {arg_ids[1]}")
            return result, lines

        # Check if it's a GLSL.std.450 function
        glsl_name = LUX_TO_GLSL.get(fname)
        if glsl_name:
            args_str = " ".join(arg_ids)
            lines.append(f"{result} = OpExtInst {result_type} {self.glsl_ext_id} {glsl_name} {args_str}")
            return result, lines

        # dot -> OpDot
        if fname == "dot":
            lines.append(f"{result} = OpDot {result_type} {arg_ids[0]} {arg_ids[1]}")
            return result, lines

        # User-defined function — inline it
        fn_def = self._find_user_function(fname)
        if fn_def is not None:
            return self._gen_inline_call(fn_def, arg_ids, result_type, lines)

        raise ValueError(f"Unknown function in codegen: {fname}")

    def _find_user_function(self, name: str) -> FunctionDef | None:
        for fn in self.module.functions:
            if fn.name == name:
                return fn
        for fn in self.stage.functions:
            if fn.name == name and fn.name != "main":
                return fn
        return None

    def _gen_inline_call(
        self, fn: FunctionDef, arg_ids: list[str], result_type_id: str,
        lines: list[str]
    ) -> tuple[str, list[str]]:
        """Inline a user-defined function call by evaluating its body."""
        # Save and create new local var scope for the inlined function
        saved_locals = self.local_vars
        saved_local_types = self.local_types
        self.local_vars = dict(self.local_vars)
        self.local_types = dict(self.local_types)

        # Use unique names to avoid collisions with outer scope
        inline_id = self.reg.next_id().replace("%", "")

        # Bind parameters to argument SSA ids using temp variables
        for param, arg_id in zip(fn.params, arg_ids):
            unique_name = f"_inline_{inline_id}_{param.name}"
            self._alloc_local(unique_name, param.type_name)
            lines.append(f"OpStore {self.local_vars[unique_name]} {arg_id}")
            self.local_vars[param.name] = self.local_vars[unique_name]
            self.local_types[param.name] = param.type_name

        # Pre-declare locals for the inlined function body
        for stmt in fn.body:
            if isinstance(stmt, LetStmt):
                unique_name = f"_inline_{inline_id}_{stmt.name}"
                self._alloc_local(unique_name, stmt.type_name)
                self.local_vars[stmt.name] = self.local_vars[unique_name]
                self.local_types[stmt.name] = stmt.type_name

        # Execute body statements, capture return value
        return_val = None
        for stmt in fn.body:
            if isinstance(stmt, ReturnStmt):
                val_id, val_lines = self._gen_expr(stmt.value)
                lines.extend(val_lines)
                return_val = val_id
                break
            else:
                lines.extend(self._gen_stmt(stmt))

        # Restore scope
        self.local_vars = saved_locals
        self.local_types = saved_local_types

        if return_val is None:
            raise ValueError(f"Inlined function '{fn.name}' has no return statement")
        return return_val, lines

    def _gen_constructor(self, expr: ConstructorExpr, lines: list[str]) -> tuple[str, list[str]]:
        type_name = expr.type_name
        target_type = resolve_type(type_name)
        result_type_id = self.reg.lux_type_to_spirv(type_name)

        # Evaluate all args
        arg_ids = []
        arg_type_names = []
        for arg in expr.args:
            aid, alines = self._gen_expr(arg)
            lines.extend(alines)
            arg_ids.append(aid)
            arg_type_names.append(self._resolve_expr_type_name(arg))

        if isinstance(target_type, VectorType):
            target_size = target_type.size
            # Expand args: e.g., vec4(vec3, scalar) -> 4 components
            components = []
            for aid, atn in zip(arg_ids, arg_type_names):
                at = resolve_type(atn)
                if isinstance(at, VectorType):
                    # Extract each component
                    for i in range(at.size):
                        comp_type = self.reg.float32()
                        c = self.reg.next_id()
                        lines.append(f"{c} = OpCompositeExtract {comp_type} {aid} {i}")
                        components.append(c)
                else:
                    components.append(aid)

            # If single scalar arg, splat to all components
            if len(components) == 1 and target_size > 1:
                components = components * target_size

            if len(components) != target_size:
                raise ValueError(
                    f"Constructor {type_name} expects {target_size} components, got {len(components)}"
                )

            result = self.reg.next_id()
            parts = " ".join(components)
            lines.append(f"{result} = OpCompositeConstruct {result_type_id} {parts}")
            return result, lines

        elif isinstance(target_type, MatrixType):
            # mat4(col0, col1, col2, col3) or mat4(scalar) for identity-ish
            result = self.reg.next_id()
            parts = " ".join(arg_ids)
            lines.append(f"{result} = OpCompositeConstruct {result_type_id} {parts}")
            return result, lines

        raise ValueError(f"Unknown constructor type: {type_name}")

    def _gen_swizzle(self, expr: SwizzleAccess, lines: list[str]) -> tuple[str, list[str]]:
        obj_id, obj_lines = self._gen_expr(expr.object)
        lines.extend(obj_lines)

        components = expr.components
        indices = [_swizzle_index(c) for c in components]

        if len(indices) == 1:
            # Single component extract
            result_type = self.reg.float32()
            result = self.reg.next_id()
            lines.append(f"{result} = OpCompositeExtract {result_type} {obj_id} {indices[0]}")
            return result, lines
        else:
            # Multi-component shuffle
            n = len(indices)
            result_type = self.reg.lux_type_to_spirv(f"vec{n}")
            result = self.reg.next_id()
            idx_str = " ".join(str(i) for i in indices)
            lines.append(f"{result} = OpVectorShuffle {result_type} {obj_id} {obj_id} {idx_str}")
            return result, lines

    def _gen_field_access(self, expr: FieldAccess, lines: list[str]) -> tuple[str, list[str]]:
        # This handles struct.field — for uniform block fields accessed via dot
        # In Lux, uniform fields are accessed directly by name, not struct.field
        # This path would be for e.g. push.view_pos
        obj_id, obj_lines = self._gen_expr(expr.object)
        lines.extend(obj_lines)
        result_type = self.reg.float32()  # simplified
        result = self.reg.next_id()
        lines.append(f"{result} = OpCompositeExtract {result_type} {obj_id} 0")
        return result, lines

    def _gen_index_access(self, expr: IndexAccess, lines: list[str]) -> tuple[str, list[str]]:
        obj_id, obj_lines = self._gen_expr(expr.object)
        lines.extend(obj_lines)
        idx_id, idx_lines = self._gen_expr(expr.index)
        lines.extend(idx_lines)
        result_type = self.reg.lux_type_to_spirv(expr.resolved_type)
        result = self.reg.next_id()
        lines.append(f"{result} = OpCompositeExtract {result_type} {obj_id} 0")  # simplified
        return result, lines

    def _gen_ternary(self, expr: TernaryExpr, lines: list[str]) -> tuple[str, list[str]]:
        cond_id, cond_lines = self._gen_expr(expr.condition)
        lines.extend(cond_lines)
        then_id, then_lines = self._gen_expr(expr.then_expr)
        lines.extend(then_lines)
        else_id, else_lines = self._gen_expr(expr.else_expr)
        lines.extend(else_lines)
        result_type = self.reg.lux_type_to_spirv(expr.resolved_type)
        result = self.reg.next_id()
        lines.append(f"{result} = OpSelect {result_type} {cond_id} {then_id} {else_id}")
        return result, lines

    def _resolve_expr_lux_type(self, expr) -> str:
        if hasattr(expr, "resolved_type") and expr.resolved_type:
            return expr.resolved_type
        return "scalar"

    def _resolve_expr_type_name(self, expr) -> str:
        return self._resolve_expr_lux_type(expr)


def _swizzle_index(c: str) -> int:
    return {"x": 0, "y": 1, "z": 2, "w": 3,
            "r": 0, "g": 1, "b": 2, "a": 3}[c]
