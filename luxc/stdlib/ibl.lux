// Lux Standard Library: Image-Based Lighting (IBL)
// Pre-filtered environment map specular + irradiance diffuse.

import brdf;

// --- Specular IBL ---
// Uses pre-filtered environment map + split-sum BRDF LUT.

fn ibl_specular_contribution(
    n_dot_v: scalar,
    roughness: scalar,
    f0: vec3,
    brdf_lut_sample: vec2
) -> vec3 {
    // brdf_lut_sample.x = scale, brdf_lut_sample.y = bias
    return f0 * brdf_lut_sample.x + vec3(brdf_lut_sample.y);
}

// --- Diffuse IBL ---
// Uses irradiance cubemap or SH coefficients.

fn ibl_diffuse_contribution(
    irradiance: vec3,
    albedo: vec3,
    metallic: scalar,
    f0: vec3,
    n_dot_v: scalar
) -> vec3 {
    // Energy conservation: (1 - F) * (1 - metallic) * albedo
    let f: vec3 = fresnel_schlick(n_dot_v, f0);
    let kd: vec3 = (vec3(1.0) - f) * (1.0 - metallic);
    return kd * albedo * irradiance;
}

// --- Spherical Harmonics ---
// L2 SH irradiance evaluation (9 coefficients per color channel).

fn sh_irradiance_l0(sh0: vec3) -> vec3 {
    // Band 0: constant term
    return sh0 * 0.282095;
}

fn sh_irradiance_l1(sh1: vec3, sh2: vec3, sh3: vec3, n: vec3) -> vec3 {
    // Band 1: linear terms
    return sh1 * 0.488603 * n.y + sh2 * 0.488603 * n.z + sh3 * 0.488603 * n.x;
}

fn sh_irradiance_l2(sh4: vec3, sh5: vec3, sh6: vec3, sh7: vec3, sh8: vec3, n: vec3) -> vec3 {
    // Band 2: quadratic terms
    return sh4 * 1.092548 * n.x * n.y
         + sh5 * 1.092548 * n.y * n.z
         + sh6 * 0.315392 * (3.0 * n.z * n.z - 1.0)
         + sh7 * 1.092548 * n.x * n.z
         + sh8 * 0.546274 * (n.x * n.x - n.y * n.y);
}

// --- Combined Direct + IBL with Multi-Scattering ---
// Fdez-Aguera 2019: multi-scattering energy compensation for split-sum IBL.

fn gltf_pbr_ibl(
    n: vec3, v: vec3, l: vec3,
    albedo: vec3, roughness: scalar, metallic: scalar,
    prefiltered: vec3, irradiance: vec3, brdf_sample: vec2,
    ao: scalar, light_color: vec3
) -> vec3 {
    // Direct lighting
    let direct: vec3 = gltf_pbr(n, v, l, albedo, roughness, metallic);
    let n_dot_l: scalar = max(dot(n, l), 0.0);
    let direct_lit: vec3 = direct * n_dot_l * light_color;

    // IBL with roughness-dependent Fresnel and multi-scattering (Fdez-Aguera 2019)
    let f0: vec3 = mix(vec3(0.04), albedo, metallic);
    let n_dot_v: scalar = max(dot(n, v), 0.001);

    // Roughness-dependent Fresnel: limit rim at high roughness
    let fr: vec3 = max(vec3(1.0 - roughness), f0) - f0;
    let k_s: vec3 = f0 + fr * pow(clamp(1.0 - n_dot_v, 0.0, 1.0), 5.0);

    let e_ss: scalar = brdf_sample.x + brdf_sample.y;
    let f_single: vec3 = k_s * brdf_sample.x + vec3(brdf_sample.y);
    let f_avg: vec3 = f0 + (vec3(1.0) - f0) * (1.0 / 21.0);
    let f_ms: vec3 = f_single * f_avg / (vec3(1.0) - f_avg * (1.0 - e_ss));
    let f_total: vec3 = f_single + f_ms * (1.0 - e_ss);
    let ibl_spec: vec3 = f_total * prefiltered;

    // Energy-conserving diffuse: subtract full specular weight
    let kd: vec3 = (vec3(1.0) - f_total) * (1.0 - metallic);
    let ibl_diff: vec3 = kd * albedo * irradiance;

    let ambient: vec3 = (ibl_diff + ibl_spec) * ao;
    return direct_lit + ambient;
}

// --- BRDF Integration LUT Generation ---
// Generates the split-sum LUT value for a given (NdotV, roughness) pair.
// This is typically pre-baked offline but can be computed in a shader.

fn importance_sample_ggx_approx(n_dot_v: scalar, roughness: scalar) -> vec2 {
    // Analytical approximation of the BRDF integration (Karis 2014)
    let a: scalar = roughness;
    let x: scalar = n_dot_v;

    // Approximation from Real Shading in Unreal Engine 4
    let scale: scalar = 1.0 - a * max(1.0 - x, x) * (1.0 / 3.14159265);
    let bias: scalar = a * max(0.0, 0.75 - x) * (1.0 / 3.14159265);

    return vec2(clamp(scale, 0.0, 1.0), clamp(bias, 0.0, 1.0));
}
