// Lux Standard Library: BRDF Functions
// Physically-based rendering building blocks

// --- Radiometric type aliases ---
type Radiance = vec3;
type Reflectance = vec3;
type Direction = vec3;
type Normal = vec3;
type Irradiance = vec3;

// --- Constants ---
const PI: scalar = 3.14159265358979;
const INV_PI: scalar = 0.31830988618379;
const EPSILON: scalar = 0.00001;

// --- Fresnel ---

fn fresnel_schlick(cos_theta: scalar, f0: vec3) -> vec3 {
    return f0 + (vec3(1.0) - f0) * pow(clamp(1.0 - cos_theta, 0.0, 1.0), 5.0);
}

fn fresnel_schlick_roughness(cos_theta: scalar, f0: vec3, roughness: scalar) -> vec3 {
    return f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow(clamp(1.0 - cos_theta, 0.0, 1.0), 5.0);
}

// --- Normal Distribution Functions ---

fn ggx_ndf(n_dot_h: scalar, roughness: scalar) -> scalar {
    let a: scalar = roughness * roughness;
    let a2: scalar = a * a;
    let denom: scalar = n_dot_h * n_dot_h * (a2 - 1.0) + 1.0;
    return a2 * INV_PI / (denom * denom + EPSILON);
}

// --- Geometry / Masking Functions ---

fn smith_ggx_g1(n_dot_v: scalar, roughness: scalar) -> scalar {
    let r: scalar = roughness + 1.0;
    let k: scalar = r * r / 8.0;
    return n_dot_v / (n_dot_v * (1.0 - k) + k + EPSILON);
}

fn smith_ggx(n_dot_v: scalar, n_dot_l: scalar, roughness: scalar) -> scalar {
    let g1v: scalar = smith_ggx_g1(n_dot_v, roughness);
    let g1l: scalar = smith_ggx_g1(n_dot_l, roughness);
    return g1v * g1l;
}

// --- Complete BRDF Evaluation ---

fn lambert_brdf(albedo: vec3, n_dot_l: scalar) -> vec3 {
    return albedo * INV_PI * max(n_dot_l, 0.0);
}

fn microfacet_brdf(n: vec3, v: vec3, l: vec3, roughness: scalar, f0: vec3) -> vec3 {
    let h: vec3 = normalize(v + l);
    let n_dot_h: scalar = max(dot(n, h), 0.0);
    let n_dot_v: scalar = max(dot(n, v), 0.0);
    let n_dot_l: scalar = max(dot(n, l), 0.0);
    let h_dot_v: scalar = max(dot(h, v), 0.0);

    let d: scalar = ggx_ndf(n_dot_h, roughness);
    let g: scalar = smith_ggx(n_dot_v, n_dot_l, roughness);
    let f: vec3 = fresnel_schlick(h_dot_v, f0);

    let numerator: vec3 = f * d * g;
    let denominator: scalar = 4.0 * n_dot_v * n_dot_l + EPSILON;
    return numerator / denominator;
}

// --- Composite BRDF ---

fn pbr_brdf(n: vec3, v: vec3, l: vec3, albedo: vec3, roughness: scalar, metallic: scalar) -> vec3 {
    let f0_dielectric: vec3 = vec3(0.04);
    let f0: vec3 = mix(f0_dielectric, albedo, vec3(metallic));

    let h: vec3 = normalize(v + l);
    let h_dot_v: scalar = max(dot(h, v), 0.0);
    let n_dot_l: scalar = max(dot(n, l), 0.0);

    let f: vec3 = fresnel_schlick(h_dot_v, f0);
    let kd: vec3 = (vec3(1.0) - f) * (1.0 - metallic);

    let diffuse: vec3 = kd * albedo * INV_PI;
    let specular: vec3 = microfacet_brdf(n, v, l, roughness, f0);

    return (diffuse + specular) * n_dot_l;
}
