// Lux Standard Library: BRDF Functions
// Physically-based rendering building blocks

// --- Radiometric type aliases ---
type Radiance = vec3;
type Reflectance = vec3;
type Direction = vec3;
type Normal = vec3;
type Irradiance = vec3;

// --- Constants ---
const PI: scalar = 3.14159265358979;
const INV_PI: scalar = 0.31830988618379;
const EPSILON: scalar = 0.00001;

// --- Fresnel ---

fn fresnel_schlick(cos_theta: scalar, f0: vec3) -> vec3 {
    return f0 + (vec3(1.0) - f0) * pow(clamp(1.0 - cos_theta, 0.0, 1.0), 5.0);
}

fn fresnel_schlick_roughness(cos_theta: scalar, f0: vec3, roughness: scalar) -> vec3 {
    return f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow(clamp(1.0 - cos_theta, 0.0, 1.0), 5.0);
}

// --- Normal Distribution Functions ---

fn ggx_ndf(n_dot_h: scalar, roughness: scalar) -> scalar {
    let a: scalar = roughness * roughness;
    let a2: scalar = a * a;
    let denom: scalar = n_dot_h * n_dot_h * (a2 - 1.0) + 1.0;
    return a2 * INV_PI / (denom * denom + EPSILON);
}

// --- Geometry / Masking Functions ---

fn smith_ggx_g1(n_dot_v: scalar, roughness: scalar) -> scalar {
    let r: scalar = roughness + 1.0;
    let k: scalar = r * r / 8.0;
    return n_dot_v / (n_dot_v * (1.0 - k) + k + EPSILON);
}

fn smith_ggx(n_dot_v: scalar, n_dot_l: scalar, roughness: scalar) -> scalar {
    let g1v: scalar = smith_ggx_g1(n_dot_v, roughness);
    let g1l: scalar = smith_ggx_g1(n_dot_l, roughness);
    return g1v * g1l;
}

// --- Complete BRDF Evaluation ---

fn lambert_brdf(albedo: vec3, n_dot_l: scalar) -> vec3 {
    return albedo * INV_PI * max(n_dot_l, 0.0);
}

fn microfacet_brdf(n: vec3, v: vec3, l: vec3, roughness: scalar, f0: vec3) -> vec3 {
    let h: vec3 = normalize(v + l);
    let n_dot_h: scalar = max(dot(n, h), 0.0);
    let n_dot_v: scalar = max(dot(n, v), 0.0);
    let n_dot_l: scalar = max(dot(n, l), 0.0);
    let h_dot_v: scalar = max(dot(h, v), 0.0);

    let d: scalar = ggx_ndf(n_dot_h, roughness);
    let g: scalar = smith_ggx(n_dot_v, n_dot_l, roughness);
    let f: vec3 = fresnel_schlick(h_dot_v, f0);

    let numerator: vec3 = f * d * g;
    let denominator: scalar = 4.0 * n_dot_v * n_dot_l + EPSILON;
    return numerator / denominator;
}

// --- Fast / Approximate Variants ---

fn ggx_ndf_fast(n_dot_h: scalar, roughness: scalar) -> scalar {
    let a: scalar = roughness * roughness;
    let d: scalar = n_dot_h * n_dot_h * (a - 1.0) + 1.0;
    return a * INV_PI / (d * d + EPSILON);
}

fn smith_ggx_fast(n_dot_v: scalar, n_dot_l: scalar, roughness: scalar) -> scalar {
    let a: scalar = roughness * roughness;
    let ggxv: scalar = n_dot_l * (n_dot_v * (1.0 - a) + a);
    let ggxl: scalar = n_dot_v * (n_dot_l * (1.0 - a) + a);
    return 0.5 / (ggxv + ggxl + EPSILON);
}

fn microfacet_brdf_fast(n: vec3, v: vec3, l: vec3, roughness: scalar, f0: vec3) -> vec3 {
    let h: vec3 = normalize(v + l);
    let n_dot_h: scalar = max(dot(n, h), 0.0);
    let n_dot_v: scalar = max(dot(n, v), 0.0);
    let n_dot_l: scalar = max(dot(n, l), 0.0);
    let h_dot_v: scalar = max(dot(h, v), 0.0);

    let d: scalar = ggx_ndf_fast(n_dot_h, roughness);
    let g: scalar = smith_ggx_fast(n_dot_v, n_dot_l, roughness);
    let f: vec3 = fresnel_schlick(h_dot_v, f0);

    return f * d * g;
}

fn microfacet_brdf_roughness(n: vec3, v: vec3, l: vec3, roughness: scalar, f0: vec3) -> vec3 {
    let h: vec3 = normalize(v + l);
    let n_dot_h: scalar = max(dot(n, h), 0.0);
    let n_dot_v: scalar = max(dot(n, v), 0.0);
    let n_dot_l: scalar = max(dot(n, l), 0.0);
    let h_dot_v: scalar = max(dot(h, v), 0.0);

    let d: scalar = ggx_ndf(n_dot_h, roughness);
    let g: scalar = smith_ggx(n_dot_v, n_dot_l, roughness);
    let f: vec3 = fresnel_schlick_roughness(h_dot_v, f0, roughness);

    let numerator: vec3 = f * d * g;
    let denominator: scalar = 4.0 * n_dot_v * n_dot_l + EPSILON;
    return numerator / denominator;
}

fn pbr_brdf_fast(n: vec3, v: vec3, l: vec3, albedo: vec3, roughness: scalar, metallic: scalar) -> vec3 {
    let f0_dielectric: vec3 = vec3(0.04);
    let f0: vec3 = mix(f0_dielectric, albedo, vec3(metallic));

    let h: vec3 = normalize(v + l);
    let h_dot_v: scalar = max(dot(h, v), 0.0);
    let n_dot_l: scalar = max(dot(n, l), 0.0);

    let f: vec3 = fresnel_schlick(h_dot_v, f0);
    let kd: vec3 = (vec3(1.0) - f) * (1.0 - metallic);

    let diffuse: vec3 = kd * albedo * INV_PI;
    let specular: vec3 = microfacet_brdf_fast(n, v, l, roughness, f0);

    return (diffuse + specular) * n_dot_l;
}

// --- Height-Correlated Smith G (glTF spec-compliant) ---

fn v_ggx_correlated(n_dot_l: scalar, n_dot_v: scalar, roughness: scalar) -> scalar {
    let a2: scalar = roughness * roughness * roughness * roughness;
    let ggxv: scalar = n_dot_l * sqrt(n_dot_v * n_dot_v * (1.0 - a2) + a2);
    let ggxl: scalar = n_dot_v * sqrt(n_dot_l * n_dot_l * (1.0 - a2) + a2);
    return 0.5 / (ggxv + ggxl + EPSILON);
}

// --- Diffuse Models ---

fn oren_nayar_diffuse(albedo: vec3, roughness: scalar, n_dot_l: scalar, n_dot_v: scalar) -> vec3 {
    let sigma2: scalar = roughness * roughness;
    let a: scalar = 1.0 - 0.5 * sigma2 / (sigma2 + 0.33);
    let b: scalar = 0.45 * sigma2 / (sigma2 + 0.09);
    let sin_theta_l: scalar = sqrt(max(1.0 - n_dot_l * n_dot_l, 0.0));
    let sin_theta_v: scalar = sqrt(max(1.0 - n_dot_v * n_dot_v, 0.0));
    let s: scalar = max(sin_theta_l, sin_theta_v);
    return albedo * INV_PI * (a + b * s) * max(n_dot_l, 0.0);
}

fn burley_diffuse(albedo: vec3, roughness: scalar, n_dot_l: scalar, n_dot_v: scalar, v_dot_h: scalar) -> vec3 {
    let fd90: scalar = 0.5 + 2.0 * roughness * v_dot_h * v_dot_h;
    let light_scatter: scalar = 1.0 + (fd90 - 1.0) * pow(1.0 - n_dot_l, 5.0);
    let view_scatter: scalar = 1.0 + (fd90 - 1.0) * pow(1.0 - n_dot_v, 5.0);
    return albedo * INV_PI * light_scatter * view_scatter * max(n_dot_l, 0.0);
}

// --- Conductor Fresnel (metals with complex IOR) ---

fn conductor_fresnel(f0: vec3, f82: vec3, v_dot_h: scalar) -> vec3 {
    let costh: scalar = clamp(v_dot_h, 0.0, 1.0);
    let one_minus: scalar = 1.0 - costh;
    let one_minus5: scalar = pow(one_minus, 5.0);
    let schlick: vec3 = f0 + (vec3(1.0) - f0) * one_minus5;
    let lazanyi: scalar = costh * pow(one_minus, 6.0);
    return schlick - lazanyi * (vec3(1.0) - f82);
}

// --- Sheen (Charlie NDF + Visibility) ---

fn charlie_ndf(roughness: scalar, n_dot_h: scalar) -> scalar {
    let alpha: scalar = roughness * roughness;
    let inv_alpha: scalar = 1.0 / alpha;
    let cos2h: scalar = n_dot_h * n_dot_h;
    let sin2h: scalar = max(1.0 - cos2h, 0.0);
    return (2.0 + inv_alpha) * pow(sin2h, inv_alpha * 0.5) / (2.0 * PI);
}

fn sheen_visibility(n_dot_l: scalar, n_dot_v: scalar) -> scalar {
    return 1.0 / (4.0 * (n_dot_l + n_dot_v - n_dot_l * n_dot_v) + EPSILON);
}

fn sheen_brdf(sheen_color: vec3, roughness: scalar, n_dot_h: scalar, n_dot_l: scalar, n_dot_v: scalar) -> vec3 {
    let d: scalar = charlie_ndf(roughness, n_dot_h);
    let vis: scalar = sheen_visibility(n_dot_l, n_dot_v);
    return sheen_color * d * vis * max(n_dot_l, 0.0);
}

// --- Clearcoat ---

fn clearcoat_brdf(n: vec3, v: vec3, l: vec3, clearcoat: scalar, clearcoat_roughness: scalar) -> scalar {
    let h: vec3 = normalize(v + l);
    let n_dot_h: scalar = max(dot(n, h), 0.0);
    let n_dot_l: scalar = max(dot(n, l), 0.0);
    let n_dot_v: scalar = max(dot(n, v), 0.0);
    let v_dot_h: scalar = max(dot(v, h), 0.0);
    let d: scalar = ggx_ndf(n_dot_h, clearcoat_roughness);
    let vis: scalar = v_ggx_correlated(n_dot_l, n_dot_v, clearcoat_roughness);
    let f0: scalar = 0.04;
    let f: scalar = f0 + (1.0 - f0) * pow(1.0 - v_dot_h, 5.0);
    return clearcoat * d * vis * f * n_dot_l;
}

// --- Anisotropic GGX ---

fn anisotropic_ggx_ndf(n_dot_h: scalar, t_dot_h: scalar, b_dot_h: scalar, at: scalar, ab: scalar) -> scalar {
    let f: scalar = t_dot_h * t_dot_h / (at * at) + b_dot_h * b_dot_h / (ab * ab) + n_dot_h * n_dot_h;
    return 1.0 / (PI * at * ab * f * f + EPSILON);
}

fn anisotropic_v_ggx(n_dot_l: scalar, n_dot_v: scalar, t_dot_v: scalar, b_dot_v: scalar, t_dot_l: scalar, b_dot_l: scalar, at: scalar, ab: scalar) -> scalar {
    let ggxv: scalar = n_dot_l * sqrt(t_dot_v * t_dot_v * at * at + b_dot_v * b_dot_v * ab * ab + n_dot_v * n_dot_v);
    let ggxl: scalar = n_dot_v * sqrt(t_dot_l * t_dot_l * at * at + b_dot_l * b_dot_l * ab * ab + n_dot_l * n_dot_l);
    return 0.5 / (ggxv + ggxl + EPSILON);
}

// --- Volume / Transmission ---

fn volume_attenuation(distance: scalar, attenuation_color: vec3, attenuation_distance: scalar) -> vec3 {
    let t: vec3 = log(attenuation_color) / attenuation_distance;
    return exp(t * distance);
}

fn ior_to_f0(ior: scalar) -> scalar {
    let r: scalar = (ior - 1.0) / (ior + 1.0);
    return r * r;
}

// --- Composite BRDF ---

fn pbr_brdf(n: vec3, v: vec3, l: vec3, albedo: vec3, roughness: scalar, metallic: scalar) -> vec3 {
    let f0_dielectric: vec3 = vec3(0.04);
    let f0: vec3 = mix(f0_dielectric, albedo, vec3(metallic));

    let h: vec3 = normalize(v + l);
    let h_dot_v: scalar = max(dot(h, v), 0.0);
    let n_dot_l: scalar = max(dot(n, l), 0.0);

    let f: vec3 = fresnel_schlick(h_dot_v, f0);
    let kd: vec3 = (vec3(1.0) - f) * (1.0 - metallic);

    let diffuse: vec3 = kd * albedo * INV_PI;
    let specular: vec3 = microfacet_brdf(n, v, l, roughness, f0);

    return (diffuse + specular) * n_dot_l;
}

// --- glTF PBR (spec-compliant with height-correlated Smith) ---

fn gltf_pbr(n: vec3, v: vec3, l: vec3, albedo: vec3, roughness: scalar, metallic: scalar) -> vec3 {
    let f0_dielectric: vec3 = vec3(0.04);
    let f0: vec3 = mix(f0_dielectric, albedo, vec3(metallic));

    let h: vec3 = normalize(v + l);
    let n_dot_h: scalar = max(dot(n, h), 0.0);
    let n_dot_v: scalar = max(dot(n, v), EPSILON);
    let n_dot_l: scalar = max(dot(n, l), EPSILON);
    let v_dot_h: scalar = max(dot(v, h), 0.0);

    let d: scalar = ggx_ndf(n_dot_h, roughness);
    let vis: scalar = v_ggx_correlated(n_dot_l, n_dot_v, roughness);
    let f: vec3 = fresnel_schlick(v_dot_h, f0);

    let kd: vec3 = (vec3(1.0) - f) * (1.0 - metallic);
    let diffuse: vec3 = kd * albedo * INV_PI;
    let specular: vec3 = f * d * vis;

    return (diffuse + specular) * n_dot_l;
}

// =====================================================================
// P5.3 â€” Advanced Material Models
// =====================================================================

// --- Transmission BTDF (glTF KHR_materials_transmission) ---
// Thin-surface model: no net macroscopic refraction, Jacobian dropped.
// Same D and G as specular BRDF, but half-vector is for transmitted ray.

fn transmission_btdf(n: vec3, v: vec3, l: vec3, roughness: scalar, ior: scalar) -> scalar {
    // Thin-surface half-vector: reflected view through surface
    let h: vec3 = normalize(v + l);
    let n_dot_h: scalar = max(dot(n, h), 0.0);
    let n_dot_v: scalar = max(dot(n, v), EPSILON);
    let n_dot_l: scalar = max(dot(n, l), EPSILON);

    let d: scalar = ggx_ndf(n_dot_h, roughness);
    let vis: scalar = v_ggx_correlated(n_dot_l, n_dot_v, roughness);

    return d * vis;
}

fn transmission_color(base_color: vec3, btdf: scalar, transmission_factor: scalar) -> vec3 {
    return base_color * btdf * transmission_factor;
}

fn diffuse_transmission(albedo: vec3, n_dot_l: scalar) -> vec3 {
    // Back-face Lambert: same as lambert_brdf but for transmitted light
    return albedo * INV_PI * max(-n_dot_l, 0.0);
}

// --- Volumetric Refraction BTDF (Walter et al. 2007) ---
// For thick refractive surfaces with actual macroscopic refraction.

fn volumetric_btdf(n: vec3, v: vec3, l: vec3, roughness: scalar, eta_i: scalar, eta_o: scalar) -> scalar {
    // Refraction half-vector
    let ht: vec3 = normalize(v * eta_i + l * eta_o);
    let n_dot_ht: scalar = abs(dot(n, ht));
    let v_dot_ht: scalar = abs(dot(v, ht));
    let l_dot_ht: scalar = abs(dot(l, ht));
    let n_dot_v: scalar = max(abs(dot(n, v)), EPSILON);
    let n_dot_l: scalar = max(abs(dot(n, l)), EPSILON);

    let d: scalar = ggx_ndf(n_dot_ht, roughness);
    let vis: scalar = v_ggx_correlated(n_dot_l, n_dot_v, roughness);

    // Walter Jacobian: eta_o^2 / (eta_i * VdotH + eta_o * LdotH)^2
    let denom: scalar = eta_i * v_dot_ht + eta_o * l_dot_ht;
    let jacobian: scalar = eta_o * eta_o / (denom * denom + EPSILON);

    return d * vis * v_dot_ht * l_dot_ht * jacobian / (n_dot_v * n_dot_l + EPSILON);
}

// --- Iridescence (glTF KHR_materials_iridescence) ---
// Thin-film interference using Belcour & Barla 2017 Fourier approach.

fn iridescence_f0_to_ior(f0: scalar) -> scalar {
    let s: scalar = sqrt(clamp(f0, 0.0, 0.9999));
    return (1.0 + s) / (1.0 - s + EPSILON);
}

fn iridescence_ior_to_f0(n_t: scalar, n_i: scalar) -> scalar {
    let r: scalar = (n_t - n_i) / (n_t + n_i + EPSILON);
    return r * r;
}

fn iridescence_sensitivity(opd: scalar, shift: vec3) -> vec3 {
    // Spectral evaluation via Gaussian-approximated CIE XYZ curves
    // OPD in nanometers, phase = 2*pi * OPD * 1e-9
    let phase: scalar = opd * 0.00000000628318530;

    // CIE XYZ Gaussian approximation parameters (amplitude, center, variance)
    // X primary lobe
    let x1: scalar = 5.4856e-13 * sqrt(6.2832 * 4.3278e9) * cos(1.6810e6 * phase + shift.x) * exp(-4.3278e9 * phase * phase);
    // X secondary lobe
    let x2: scalar = 9.7470e-14 * sqrt(6.2832 * 4.5282e9) * cos(2.2399e6 * phase + shift.x) * exp(-4.5282e9 * phase * phase);
    // Y
    let y: scalar = 4.4201e-13 * sqrt(6.2832 * 9.3046e9) * cos(1.7953e6 * phase + shift.y) * exp(-9.3046e9 * phase * phase);
    // Z
    let z: scalar = 5.2481e-13 * sqrt(6.2832 * 6.6121e9) * cos(2.2084e6 * phase + shift.z) * exp(-6.6121e9 * phase * phase);

    let xyz: vec3 = vec3(x1 + x2, y, z) / 1.0685e-7;

    // XYZ to sRGB (Rec. 709)
    let r: scalar = xyz.x * 3.2404542 + xyz.y * -1.5371385 + xyz.z * -0.4985314;
    let g: scalar = xyz.x * -0.9692660 + xyz.y * 1.8760108 + xyz.z * 0.0415560;
    let b: scalar = xyz.x * 0.0556434 + xyz.y * -0.2040259 + xyz.z * 1.0572252;

    return vec3(r, g, b);
}

fn iridescence_fresnel(outside_ior: scalar, film_ior: scalar, base_f0: vec3, thickness: scalar, cos_theta: scalar) -> vec3 {
    // Snell's law: refracted angle inside film
    let sin_theta1_sq: scalar = 1.0 - cos_theta * cos_theta;
    let sin_theta2_sq: scalar = sin_theta1_sq * (outside_ior * outside_ior) / (film_ior * film_ior);

    // Total internal reflection check
    let cos_theta2: scalar = sqrt(max(1.0 - sin_theta2_sq, 0.0));

    // Interface reflectances
    let r12_f0: scalar = iridescence_ior_to_f0(film_ior, outside_ior);
    let r12: scalar = r12_f0 + (1.0 - r12_f0) * pow(1.0 - cos_theta, 5.0);

    // Base interface: per-channel (base_f0 is RGB)
    let base_ior: vec3 = vec3(
        iridescence_f0_to_ior(base_f0.x),
        iridescence_f0_to_ior(base_f0.y),
        iridescence_f0_to_ior(base_f0.z)
    );
    let r23_f0: vec3 = vec3(
        iridescence_ior_to_f0(base_ior.x, film_ior),
        iridescence_ior_to_f0(base_ior.y, film_ior),
        iridescence_ior_to_f0(base_ior.z, film_ior)
    );
    let r23: vec3 = r23_f0 + (vec3(1.0) - r23_f0) * pow(1.0 - cos_theta2, 5.0);

    // Optical path difference (in nanometers)
    let opd: scalar = 2.0 * film_ior * thickness * cos_theta2;

    // Phase shifts at interfaces (half-wave loss)
    let phi12: scalar = (film_ior < outside_ior) ? PI : 0.0;
    let phi21: scalar = PI - phi12;
    let phi23: vec3 = vec3(
        (base_ior.x < film_ior) ? PI : 0.0,
        (base_ior.y < film_ior) ? PI : 0.0,
        (base_ior.z < film_ior) ? PI : 0.0
    );
    let total_phi: vec3 = vec3(phi21) + phi23;

    // Airy summation (Belcour 2017 Fourier approach)
    let r123: vec3 = clamp(vec3(r12) * r23, vec3(1.0e-5), vec3(0.9999));
    let r123_sqrt: vec3 = sqrt(r123);
    let t121: scalar = 1.0 - r12;

    let rs: vec3 = vec3(t121 * t121) * r23 / (vec3(1.0) - r123);

    // DC term
    let c0: vec3 = vec3(r12) + rs;

    // First harmonic
    let cm: vec3 = rs - vec3(t121);
    let c1: vec3 = cm * r123_sqrt;

    // Second harmonic
    let c2: vec3 = c1 * r123_sqrt;

    // Spectral integration
    let s1: vec3 = iridescence_sensitivity(opd, total_phi);
    let s2: vec3 = iridescence_sensitivity(2.0 * opd, 2.0 * total_phi);

    let result: vec3 = c0 + c1 * 2.0 * s1 + c2 * 2.0 * s2;

    return max(result, vec3(0.0));
}

// --- Dispersion (glTF KHR_materials_dispersion) ---
// Per-channel IOR via Cauchy equation with Abbe number.

fn dispersion_ior(base_ior: scalar, dispersion: scalar) -> vec3 {
    // dispersion = 20 / Vd, so half_spread = (ior-1) * 0.025 * dispersion
    let half_spread: scalar = (base_ior - 1.0) * 0.025 * dispersion;
    let ior_r: scalar = max(base_ior - half_spread, 1.0);
    let ior_g: scalar = base_ior;
    let ior_b: scalar = max(base_ior + half_spread, 1.0);
    return vec3(ior_r, ior_g, ior_b);
}

fn dispersion_refract(v: vec3, n: vec3, base_ior: scalar, dispersion: scalar) -> vec3 {
    // Refract each channel separately through its own IOR
    let iors: vec3 = dispersion_ior(base_ior, dispersion);
    let refr_r: vec3 = refract(v, n, 1.0 / iors.x);
    let refr_g: vec3 = refract(v, n, 1.0 / iors.y);
    let refr_b: vec3 = refract(v, n, 1.0 / iors.z);
    // Return per-channel deviation as angular spread
    return vec3(length(refr_r - refr_g), 0.0, length(refr_b - refr_g));
}

fn dispersion_f0(base_ior: scalar, dispersion: scalar) -> vec3 {
    // Per-channel F0 from dispersed IOR
    let iors: vec3 = dispersion_ior(base_ior, dispersion);
    return vec3(
        ior_to_f0(iors.x),
        ior_to_f0(iors.y),
        ior_to_f0(iors.z)
    );
}
